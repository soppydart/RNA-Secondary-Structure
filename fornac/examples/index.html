<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>RNA Secondary Structure</title>
    <link rel="stylesheet" href="fornac.css" />
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #f5f5f5;
        margin: 0;
        padding: 20px;
      }

      #canvas1 {
        width: 100%;
        height: 100%;
        border: 1px solid #ccc;
      }

      .container2 {
        max-width: 800px;
        margin: auto;
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        padding: 2%;
        margin-top: 2%;
        margin-bottom: 2%;
      }

      h1 {
        font-size: 24px;
        color: #333;
        text-align: center;
        margin-bottom: 20px;
      }

      #rna_ss {
        margin: auto;
        width: 100%;
        max-width: 600px;
        height: auto;
        display: block;
        margin-bottom: 20px;
        margin-top: 15px;
        border: 2px solid #ccc;
        border-radius: 8px;
      }

      .baseText {
        text-anchor: middle;
        dominant-baseline: central;
        font-size: 12px;
        font-weight: bold;
        fill: white;
      }
    </style>
  </head>

  <body>
    <!-- RNA Sequence Visualization -->
    <div class="container2">
      <h1>Maximizing number of pairs</h1>
      <div id="canvas1"></div>
    </div>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
      function findPairs(sequence) {
        const mp = new Map();
        const dp = [];
        const bondIndex = [];

        function solve(str, n) {
          for (let k = 5; k <= n - 1; k++) {
            for (let i = 0; i < n - k; i++) {
              const j = i + k;
              let val = dp[i][j - 1];
              let finalVal = -1;
              for (let t = i; t < j - 4; t++) {
                if (
                  (str[t] === "A" && str[j] === "U") ||
                  (str[t] === "U" && str[j] === "A") ||
                  (str[t] === "G" && str[j] === "C") ||
                  (str[t] === "C" && str[j] === "G")
                ) {
                  if (
                    (t - 1 < 0 ? 0 : dp[i][t - 1]) + dp[t + 1][j - 1] + 1 >
                    val
                  ) {
                    val = (t - 1 < 0 ? 0 : dp[i][t - 1]) + dp[t + 1][j - 1] + 1;
                    finalVal = t;
                  }
                }
              }
              mp.set(`${i},${j}`, finalVal);
              dp[i][j] = val;
            }
          }
        }

        function makePairs(i, j) {
          if (i >= j - 4) {
            return;
          }
          const t = mp.get(`${i},${j}`);
          if (t !== -1) {
            bondIndex.push([t, j]);
            makePairs(i, t - 1);
            makePairs(t + 1, j - 1);
          } else {
            makePairs(i, j - 1);
          }
        }

        const n = sequence.length;
        for (let i = 0; i < n; i++) {
          dp.push(Array(n).fill(0));
        }
        solve(sequence, n);
        makePairs(0, n - 1);
        return bondIndex;
      }

      // RNA sequence
      var url = new URL(window.location.href);
      const sequence = url.searchParams.get("sequence").toUpperCase();
      console.log(sequence);
      // Pairs
      const pairs = findPairs(sequence);

      const canvasWidth = 1000;
      const canvasHeight = 300;
      const baseRadius = 20;

      // Color mapping for bases
      const baseColors = {
        A: "red",
        U: "blue",
        G: "green",
        C: "orange",
      };

      const svg = d3
        .select("#canvas1")
        .append("svg")
        .attr("width", "100%")
        .attr("height", "100%")
        .attr("viewBox", `0 0 ${canvasWidth} ${canvasHeight}`)
        .call(
          d3.zoom().on("zoom", function (event) {
            svg.attr("transform", event.transform);
          })
        )
        .append("g");

      // Draw bases (spheres) and initials
      const bases = svg
        .selectAll(".base")
        .data(sequence.split(""))
        .enter()
        .append("g")
        .attr("class", "base")
        .attr(
          "transform",
          (d, i) => `translate(${i * 40 + 30},${canvasHeight / 2})`
        );

      bases
        .append("circle")
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("r", baseRadius)
        .style("fill", (d) => baseColors[d]);

      bases
        .append("text")
        .attr("class", "baseText")
        .text((d) => d)
        .attr("x", 0)
        .attr("y", 0);

      // Draw pairing lines
      pairs.forEach((pair, index) => {
        const startX = pair[0] * 40 + 30;
        const endX = pair[1] * 40 + 30;
        const startY = canvasHeight / 2 - baseRadius; // Adjusted startY
        const endY = canvasHeight / 2 - baseRadius; // Adjusted endY

        // Draw vertical lines shooting upwards from each base
        svg
          .append("line")
          .attr("x1", startX)
          .attr("y1", startY)
          .attr("x2", startX)
          .attr("y2", startY - 50 - index * 20) // Adjusted to make each line unique
          .attr("stroke", "black")
          .attr("stroke-width", 2);

        svg
          .append("line")
          .attr("x1", endX)
          .attr("y1", endY)
          .attr("x2", endX)
          .attr("y2", endY - 50 - index * 20) // Adjusted to make each line unique
          .attr("stroke", "black")
          .attr("stroke-width", 2);

        // Draw horizontal line connecting the endpoints of the vertical lines
        svg
          .append("line")
          .attr("x1", startX)
          .attr("y1", startY - 50 - index * 20) // Adjusted to make each line unique
          .attr("x2", endX)
          .attr("y2", startY - 50 - index * 20) // Adjusted to make each line unique
          .attr("stroke", "black")
          .attr("stroke-width", 2);
      });
    </script>

    <div class="container2">
      <h1>RNA Secondary Structure Visualization</h1>

      <div id="rna_ss"></div>
    </div>

    <script src="https://unpkg.com/d3@3.5"></script>
    <script src="fornac.js"></script>
    <script>
      "use strict";

      function solve(str, n) {
        let mp = new Map();
        let dp = Array.from({ length: n }, () => Array(n).fill(0));

        for (let k = 5; k <= n - 1; k++) {
          for (let i = 0, j = i + k; j < n; i++, j++) {
            let val = dp[i][j - 1];
            let finalval = -1;
            for (let t = i; t < j - 4; t++) {
              if (
                (str[t] === "A" && str[j] === "U") ||
                (str[t] === "U" && str[j] === "A") ||
                (str[t] === "G" && str[j] === "C") ||
                (str[t] === "C" && str[j] === "G")
              ) {
                if (
                  (t - 1 < 0 ? 0 : dp[i][t - 1]) + dp[t + 1][j - 1] + 1 >
                  val
                ) {
                  val = (t - 1 < 0 ? 0 : dp[i][t - 1]) + dp[t + 1][j - 1] + 1;
                  finalval = t;
                }
              }
            }
            mp.set(`${i},${j}`, finalval);
            dp[i][j] = val;
          }
        }

        return mp;
      }

      function makePairs(mp, i, j, dotStructure) {
        if (i >= j - 4) {
          return;
        }
        let t = mp.get(`${i},${j}`);
        if (t !== -1) {
          dotStructure[i] = "(";
          dotStructure[j] = ")";
          makePairs(mp, i, t - 1, dotStructure);
          makePairs(mp, t + 1, j - 1, dotStructure);
        } else {
          dotStructure[j] = ".";
          makePairs(mp, i, j - 1, dotStructure);
        }
      }

      function generateDotStructure(str) {
        let n = str.length;
        let mp = solve(str, n);
        let dotStructure = Array(n).fill(".");
        makePairs(mp, 0, n - 1, dotStructure);
        return dotStructure.join("");
      }

      function parseDotStructureFromURL(dotBracketEncoded) {
        const dotStructureParam = decodeURIComponent(dotBracketEncoded);

        const dotBracket = dotStructureParam.replace(/D/g, ".");

        return dotBracket;
      }

      function updateStructure() {
        var url = new URL(window.location.href);
        var sequence = url.searchParams.get("sequence").toUpperCase();
        var dotBracketEncoded = url.searchParams.get("dot_structure");
        // var dotBracket = dot;
        // console.log(dotBracket);
        const dotBracket = parseDotStructureFromURL(dotBracketEncoded);
        // var dotBracket = "(((((((((...((((((.........))))))........((((((.......))))))..)))))))))";

        var svg = document.getElementById("rna_ss");
        while (svg.firstChild) {
          svg.removeChild(svg.firstChild);
        }

        var options = {
          structure: dotBracket,
          sequence: sequence,
        };
        if (options.structure && options.sequence) {
          var container2 = new fornac.FornaContainer("#rna_ss", {
            animation: true,
            zoomable: true,
          });
          container2.addRNA(options.structure, options);
          container2.setSize(200, 200);
        } else {
          console.error("Error: Structure and sequence are not defined.");
        }
      }

      window.addEventListener("load", updateStructure);
    </script>
  </body>
</html>
